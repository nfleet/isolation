<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Graph` struct in crate `petgraph`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Graph">

    <title>petgraph::graph::Graph - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'><a href='../index.html'>petgraph</a>::<wbr><a href='index.html'>graph</a></p><script>window.sidebarCurrent = {name: 'Graph', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>petgraph</a>::<wbr><a href='index.html'>graph</a>::<wbr><a class='struct' href=''>Graph</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-3788' class='srclink' href='../../src/petgraph/graph.rs.html#221-225' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Graph&lt;N, E, Ty = <a class='struct' href='../../petgraph/struct.Directed.html' title='petgraph::Directed'>Directed</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a> = <a class='type' href='../../petgraph/graph/type.DefIndex.html' title='petgraph::graph::DefIndex'>DefIndex</a>&gt; {
    // some fields omitted
}</pre><div class='docblock'><p><strong>Graph&lt;N, E, Ty, Ix&gt;</strong> is a graph datastructure using an adjacency list representation.</p>

<p><strong>Graph</strong> is parameterized over the node weight <strong>N</strong>, edge weight <strong>E</strong>, 
edge type <strong>Ty</strong> that determines whether the graph has directed edges or not,
and <strong>Ix</strong> which is the index type used.</p>

<p>Based on the graph implementation in rustc.</p>

<p>The graph maintains unique indices for nodes and edges, and node and edge
weights may be accessed mutably.</p>

<p><strong>NodeIndex</strong> and <strong>EdgeIndex</strong> are types that act as references to nodes and edges,
but these are only stable across certain operations. <strong>Removing nodes or edges may shift
other indices</strong>. Adding to the graph keeps
all indices stable, but removing a node will force the last node to shift its index to
take its place. Similarly, removing an edge shifts the index of the last edge.</p>

<p>The fact that the node and edge indices in the graph are numbered in a compact interval from
0 to <em>n</em> - 1 simplifies some graph algorithms.</p>

<p>The <strong>Ix</strong> parameter is <strong>u32</strong> by default. The goal is that you can ignore this parameter
completely unless you need a very big graph -- then you can use <strong>usize</strong>.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;N, E&gt; <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, <a class='struct' href='../../petgraph/struct.Directed.html' title='petgraph::Directed'>Directed</a>&gt;</code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; Self</code></h4>
<div class='docblock'><p>Create a new <strong>Graph</strong> with directed edges.</p>
</div></div><h3 class='impl'><code>impl&lt;N, E&gt; <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, <a class='struct' href='../../petgraph/struct.Undirected.html' title='petgraph::Undirected'>Undirected</a>&gt;</code></h3><div class='impl-items'><h4 id='method.new_undirected' class='method'><code>fn <a href='#method.new_undirected' class='fnname'>new_undirected</a>() -&gt; Self</code></h4>
<div class='docblock'><p>Create a new <strong>Graph</strong> with undirected edges.</p>
</div></div><h3 class='impl'><code>impl&lt;N, E, Ty = <a class='struct' href='../../petgraph/struct.Directed.html' title='petgraph::Directed'>Directed</a>, Ix = <a class='type' href='../../petgraph/graph/type.DefIndex.html' title='petgraph::graph::DefIndex'>DefIndex</a>&gt; <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='impl-items'><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(nodes: <a href='http://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>, edges: <a href='http://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Create a new <strong>Graph</strong> with estimated capacity.</p>
</div><h4 id='method.node_count' class='method'><code>fn <a href='#method.node_count' class='fnname'>node_count</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Return the number of nodes (vertices) in the graph.</p>
</div><h4 id='method.edge_count' class='method'><code>fn <a href='#method.edge_count' class='fnname'>edge_count</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Return the number of edges in the graph.</p>

<p>Computes in <strong>O(1)</strong> time.</p>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Remove all nodes and edges</p>
</div><h4 id='method.is_directed' class='method'><code>fn <a href='#method.is_directed' class='fnname'>is_directed</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Return whether the graph has directed edges or not.</p>
</div><h4 id='method.into_edge_type' class='method'><code>fn <a href='#method.into_edge_type' class='fnname'>into_edge_type</a>&lt;NewTy&gt;(self) -&gt; <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, NewTy, Ix&gt; <span class='where'>where NewTy: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a></span></code></h4>
<div class='docblock'><p>Cast the graph as either undirected or directed. No edge adjustments
are done.</p>

<p>Computes in <strong>O(1)</strong> time.</p>
</div><h4 id='method.add_node' class='method'><code>fn <a href='#method.add_node' class='fnname'>add_node</a>(&amp;mut self, w: N) -&gt; <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;</code></h4>
<div class='docblock'><p>Add a node (also called vertex) with weight <strong>w</strong> to the graph.</p>

<p>Computes in <strong>O(1)</strong> time.</p>

<p>Return the index of the new node.</p>

<p><strong>Panics</strong> if the Graph is at the maximum number of nodes for its index
type.</p>
</div><h4 id='method.node_weight' class='method'><code>fn <a href='#method.node_weight' class='fnname'>node_weight</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;N&gt;</code></h4>
<div class='docblock'><p>Access node weight for node <strong>a</strong>.</p>
</div><h4 id='method.node_weight_mut' class='method'><code>fn <a href='#method.node_weight_mut' class='fnname'>node_weight_mut</a>(&amp;mut self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut N&gt;</code></h4>
<div class='docblock'><p>Access node weight for node <strong>a</strong>.</p>
</div><h4 id='method.neighbors' class='method'><code>fn <a href='#method.neighbors' class='fnname'>neighbors</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='struct' href='../../petgraph/graph/struct.Neighbors.html' title='petgraph::graph::Neighbors'>Neighbors</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator of all nodes with an edge starting from <strong>a</strong>.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>NodeIndex<Ix></strong>.</p>
</div><h4 id='method.neighbors_directed' class='method'><code>fn <a href='#method.neighbors_directed' class='fnname'>neighbors_directed</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='struct' href='../../petgraph/graph/struct.Neighbors.html' title='petgraph::graph::Neighbors'>Neighbors</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator of all neighbors that have an edge between them and <strong>a</strong>,
in the specified direction.
If the graph is undirected, this is equivalent to <em>.neighbors(a)</em>.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>NodeIndex<Ix></strong>.</p>
</div><h4 id='method.neighbors_undirected' class='method'><code>fn <a href='#method.neighbors_undirected' class='fnname'>neighbors_undirected</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='struct' href='../../petgraph/graph/struct.Neighbors.html' title='petgraph::graph::Neighbors'>Neighbors</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator of all neighbors that have an edge between them and <strong>a</strong>,
in either direction.
If the graph is undirected, this is equivalent to <em>.neighbors(a)</em>.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>NodeIndex<Ix></strong>.</p>
</div><h4 id='method.edges' class='method'><code>fn <a href='#method.edges' class='fnname'>edges</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='struct' href='../../petgraph/graph/struct.Edges.html' title='petgraph::graph::Edges'>Edges</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator over the neighbors of node <strong>a</strong>, paired with their respective edge
weights.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>(NodeIndex<Ix>, &amp;&#39;a E)</strong>.</p>
</div><h4 id='method.edges_directed' class='method'><code>fn <a href='#method.edges_directed' class='fnname'>edges_directed</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='struct' href='../../petgraph/graph/struct.Edges.html' title='petgraph::graph::Edges'>Edges</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator of all neighbors that have an edge between them and <strong>a</strong>,
in the specified direction, paired with the respective edge weights.</p>

<p>If the graph is undirected, this is equivalent to <em>.edges(a)</em>.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>(NodeIndex<Ix>, &amp;&#39;a E)</strong>.</p>
</div><h4 id='method.edges_both' class='method'><code>fn <a href='#method.edges_both' class='fnname'>edges_both</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='struct' href='../../petgraph/graph/struct.Edges.html' title='petgraph::graph::Edges'>Edges</a>&lt;E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator over the edgs from <strong>a</strong> to its neighbors, then <em>to</em> <strong>a</strong> from its
neighbors.</p>

<p>Produces an empty iterator if the node doesn&#39;t exist.</p>

<p>Iterator element type is <strong>(NodeIndex<Ix>, &amp;&#39;a E)</strong>.</p>
</div><h4 id='method.add_edge' class='method'><code>fn <a href='#method.add_edge' class='fnname'>add_edge</a>(&amp;mut self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, b: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, weight: E) -&gt; <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;</code></h4>
<div class='docblock'><p>Add an edge from <strong>a</strong> to <strong>b</strong> to the graph, with its edge weight.</p>

<p><strong>Note:</strong> <strong>Graph</strong> allows adding parallel (“duplicate”) edges. If you want
to avoid this, use <a href="#method.update_edge"><em>.update_edge(a, b, weight)</em></a> instead.</p>

<p>Computes in <strong>O(1)</strong> time.</p>

<p>Return the index of the new edge.</p>

<p><strong>Panics</strong> if any of the nodes don&#39;t exist.</p>

<p><strong>Panics</strong> if the Graph is at the maximum number of edges for its index
type.</p>
</div><h4 id='method.update_edge' class='method'><code>fn <a href='#method.update_edge' class='fnname'>update_edge</a>(&amp;mut self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, b: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, weight: E) -&gt; <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;</code></h4>
<div class='docblock'><p>Add or update an edge from <strong>a</strong> to <strong>b</strong>.</p>

<p>If the edge already exists, its weight is updated.</p>

<p>Computes in <strong>O(e&#39;)</strong> time, where <strong>e&#39;</strong> is the number of edges
connected to the vertices <strong>a</strong> (and <strong>b</strong>).</p>

<p>Return the index of the affected edge.</p>

<p><strong>Panics</strong> if any of the nodes don&#39;t exist.</p>
</div><h4 id='method.edge_weight' class='method'><code>fn <a href='#method.edge_weight' class='fnname'>edge_weight</a>(&amp;self, e: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;E&gt;</code></h4>
<div class='docblock'><p>Access the edge weight for <strong>e</strong>.</p>
</div><h4 id='method.edge_weight_mut' class='method'><code>fn <a href='#method.edge_weight_mut' class='fnname'>edge_weight_mut</a>(&amp;mut self, e: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut E&gt;</code></h4>
<div class='docblock'><p>Access the edge weight for <strong>e</strong> mutably.</p>
</div><h4 id='method.remove_node' class='method'><code>fn <a href='#method.remove_node' class='fnname'>remove_node</a>(&amp;mut self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;N&gt;</code></h4>
<div class='docblock'><p>Remove <strong>a</strong> from the graph if it exists, and return its weight.
If it doesn&#39;t exist in the graph, return <strong>None</strong>.</p>
</div><h4 id='method.remove_edge' class='method'><code>fn <a href='#method.remove_edge' class='fnname'>remove_edge</a>(&amp;mut self, e: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;E&gt;</code></h4>
<div class='docblock'><p>Remove an edge and return its edge weight, or <strong>None</strong> if it didn&#39;t exist.</p>

<p>Computes in <strong>O(e&#39;)</strong> time, where <strong>e&#39;</strong> is the size of four particular edge lists, for
the vertices of <strong>e</strong> and the vertices of another affected edge.</p>
</div><h4 id='method.find_edge' class='method'><code>fn <a href='#method.find_edge' class='fnname'>find_edge</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, b: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;&gt;</code></h4>
<div class='docblock'><p>Lookup an edge from <strong>a</strong> to <strong>b</strong>.</p>

<p>Computes in <strong>O(e&#39;)</strong> time, where <strong>e&#39;</strong> is the number of edges
connected to the vertices <strong>a</strong> (and <strong>b</strong>).</p>
</div><h4 id='method.find_edge_undirected' class='method'><code>fn <a href='#method.find_edge_undirected' class='fnname'>find_edge_undirected</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, b: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;, <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>)</a>&gt;</code></h4>
<div class='docblock'><p>Lookup an edge between <strong>a</strong> and <strong>b</strong>, in either direction.</p>

<p>If the graph is undirected, then this is equivalent to <em>.find_edge()</em>.</p>

<p>Return the edge index and its directionality, with <em>Outgoing</em> meaning
from <strong>a</strong> to <strong>b</strong> and <em>Incoming</em> the reverse,
or <strong>None</strong> if the edge does not exist.</p>
</div><h4 id='method.reverse' class='method'><code>fn <a href='#method.reverse' class='fnname'>reverse</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Reverse the direction of all edges</p>
</div><h4 id='method.without_edges' class='method'><code>fn <a href='#method.without_edges' class='fnname'>without_edges</a>(&amp;self, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='struct' href='../../petgraph/graph/struct.WithoutEdges.html' title='petgraph::graph::WithoutEdges'>WithoutEdges</a>&lt;N, Ty, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator over either the nodes without edges to them or from them.</p>

<p>The nodes in <em>.without_edges(Incoming)</em> are the initial nodes and 
<em>.without_edges(Outgoing)</em> are the terminals.</p>

<p>For an undirected graph, the initials/terminals are just the vertices without edges.</p>

<p>The whole iteration computes in <strong>O(|V|)</strong> time.</p>
</div><h4 id='method.node_weights_mut' class='method'><code>fn <a href='#method.node_weights_mut' class='fnname'>node_weights_mut</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../petgraph/graph/struct.NodeWeightsMut.html' title='petgraph::graph::NodeWeightsMut'>NodeWeightsMut</a>&lt;'a, N, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator yielding mutable access to all node weights.</p>

<p>The order in which weights are yielded matches the order of their
node indices.</p>
</div><h4 id='method.edge_weights_mut' class='method'><code>fn <a href='#method.edge_weights_mut' class='fnname'>edge_weights_mut</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../petgraph/graph/struct.EdgeWeightsMut.html' title='petgraph::graph::EdgeWeightsMut'>EdgeWeightsMut</a>&lt;'a, E, Ix&gt;</code></h4>
<div class='docblock'><p>Return an iterator yielding mutable access to all edge weights.</p>

<p>The order in which weights are yielded matches the order of their
edge indices.</p>
</div><h4 id='method.raw_nodes' class='method'><code>fn <a href='#method.raw_nodes' class='fnname'>raw_nodes</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../../petgraph/graph/struct.Node.html' title='petgraph::graph::Node'>Node</a>&lt;N, Ix&gt;<a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Access the internal node array.</p>
</div><h4 id='method.raw_edges' class='method'><code>fn <a href='#method.raw_edges' class='fnname'>raw_edges</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../../petgraph/graph/struct.Edge.html' title='petgraph::graph::Edge'>Edge</a>&lt;E, Ix&gt;<a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Access the internal edge array.</p>
</div><h4 id='method.first_edge' class='method'><code>fn <a href='#method.first_edge' class='fnname'>first_edge</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;&gt;</code></h4>
<div class='docblock'><p>Accessor for data structure internals: the first edge in the given direction.</p>
</div><h4 id='method.next_edge' class='method'><code>fn <a href='#method.next_edge' class='fnname'>next_edge</a>(&amp;self, e: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;&gt;</code></h4>
<div class='docblock'><p>Accessor for data structure internals: the next edge for the given direction.</p>
</div><h4 id='method.walk_edges_directed' class='method'><code>fn <a href='#method.walk_edges_directed' class='fnname'>walk_edges_directed</a>(&amp;self, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, dir: <a class='enum' href='../../petgraph/enum.EdgeDirection.html' title='petgraph::EdgeDirection'>EdgeDirection</a>) -&gt; <a class='struct' href='../../petgraph/graph/struct.WalkEdges.html' title='petgraph::graph::WalkEdges'>WalkEdges</a>&lt;Ix&gt;</code></h4>
<div class='docblock'><p>Return a “walker” object that can be used to step through the edges
of the node <strong>a</strong> in direction <strong>dir</strong>.</p>

<p>Note: The walker does not borrow from the graph, this is to allow mixing
edge walking with mutating the graph&#39;s weights.</p>
</div><h4 id='method.index_twice_mut' class='method'><code>fn <a href='#method.index_twice_mut' class='fnname'>index_twice_mut</a>&lt;T, U&gt;(&amp;mut self, i: T, j: U) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(&amp;mut Self::Output, &amp;mut Self::Output)</a> <span class='where'>where Self: <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;T&gt; + <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;U&gt;, T: <a class='trait' href='../../petgraph/graph/trait.GraphIndex.html' title='petgraph::graph::GraphIndex'>GraphIndex</a>, U: <a class='trait' href='../../petgraph/graph/trait.GraphIndex.html' title='petgraph::graph::GraphIndex'>GraphIndex</a></span></code></h4>
<div class='docblock'><p>Index the <strong>Graph</strong> by two indices, any combination of
node or edge indices is fine.</p>

<p><strong>Panics</strong> if the indices are equal or if they are out of bounds.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>petgraph</span>::{<span class='ident'>Graph</span>, <span class='ident'>Dfs</span>, <span class='ident'>Incoming</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>gr</span> <span class='op'>=</span> <span class='ident'>Graph</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>gr</span>.<span class='ident'>add_node</span>(<span class='number'>0.</span>);
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>gr</span>.<span class='ident'>add_node</span>(<span class='number'>0.</span>);
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>gr</span>.<span class='ident'>add_node</span>(<span class='number'>0.</span>);
<span class='ident'>gr</span>.<span class='ident'>add_edge</span>(<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='number'>3.</span>);
<span class='ident'>gr</span>.<span class='ident'>add_edge</span>(<span class='ident'>b</span>, <span class='ident'>c</span>, <span class='number'>2.</span>);
<span class='ident'>gr</span>.<span class='ident'>add_edge</span>(<span class='ident'>c</span>, <span class='ident'>b</span>, <span class='number'>1.</span>);

<span class='comment'>// walk the graph and sum incoming edges into the node weight</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dfs</span> <span class='op'>=</span> <span class='ident'>Dfs</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>gr</span>, <span class='ident'>a</span>);
<span class='kw'>while</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=</span> <span class='ident'>dfs</span>.<span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='ident'>gr</span>) {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>edges</span> <span class='op'>=</span> <span class='ident'>gr</span>.<span class='ident'>walk_edges_directed</span>(<span class='ident'>node</span>, <span class='ident'>Incoming</span>);
    <span class='kw'>while</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>edge</span>) <span class='op'>=</span> <span class='ident'>edges</span>.<span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='ident'>gr</span>) {
        <span class='kw'>let</span> (<span class='ident'>nw</span>, <span class='ident'>ew</span>) <span class='op'>=</span> <span class='ident'>gr</span>.<span class='ident'>index_twice_mut</span>(<span class='ident'>node</span>, <span class='ident'>edge</span>);
        <span class='op'>*</span><span class='ident'>nw</span> <span class='op'>+=</span> <span class='op'>*</span><span class='ident'>ew</span>;
    }
}

<span class='comment'>// check the result</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>gr</span>[<span class='ident'>a</span>], <span class='number'>0.</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>gr</span>[<span class='ident'>b</span>], <span class='number'>4.</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>gr</span>[<span class='ident'>c</span>], <span class='number'>2.</span>);</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;N, E, Ty, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a>&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where N: <a class='trait' href='http://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, E: <a class='trait' href='http://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a></span></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; Self</code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where N: <a class='trait' href='http://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a>, E: <a class='trait' href='http://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a>, Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='http://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;&gt; for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='docblock'><p>Index the <strong>Graph</strong> by <strong>NodeIndex</strong> to access node weights.</p>

<p><strong>Panics</strong> if the node doesn&#39;t exist.</p>
</div><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = N</code></h4>
<h4 id='method.index' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; &amp;N</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;&gt; for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='docblock'><p>Index the <strong>Graph</strong> by <strong>NodeIndex</strong> to access node weights.</p>

<p><strong>Panics</strong> if the node doesn&#39;t exist.</p>
</div><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; &amp;mut N</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;&gt; for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='docblock'><p>Index the <strong>Graph</strong> by <strong>EdgeIndex</strong> to access edge weights.</p>

<p><strong>Panics</strong> if the edge doesn&#39;t exist.</p>
</div><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = E</code></h4>
<h4 id='method.index' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;) -&gt; &amp;E</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;&gt; for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='docblock'><p>Index the <strong>Graph</strong> by <strong>EdgeIndex</strong> to access edge weights.</p>

<p><strong>Panics</strong> if the edge doesn&#39;t exist.</p>
</div><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='http://doc.rust-lang.org/nightly/core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../petgraph/graph/struct.EdgeIndex.html' title='petgraph::graph::EdgeIndex'>EdgeIndex</a>&lt;Ix&gt;) -&gt; &amp;mut E</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, N, E: 'a, Ty, Ix&gt; <a class='trait' href='../../petgraph/visit/trait.NeighborIter.html' title='petgraph::visit::NeighborIter'>NeighborIter</a>&lt;'a&gt; for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='impl-items'><h4 id='assoc_type.Iter' class='type'><code>type Iter = <a class='struct' href='../../petgraph/graph/struct.Neighbors.html' title='petgraph::graph::Neighbors'>Neighbors</a>&lt;'a, E, Ix&gt;</code></h4>
<h4 id='method.neighbors' class='method'><code>fn <a href='../../petgraph/visit/trait.NeighborIter.html#method.neighbors' class='fnname'>neighbors</a>(&amp;'a self, n: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a class='struct' href='../../petgraph/graph/struct.Neighbors.html' title='petgraph::graph::Neighbors'>Neighbors</a>&lt;'a, E, Ix&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='../../petgraph/visit/trait.Graphlike.html' title='petgraph::visit::Graphlike'>Graphlike</a> for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='impl-items'><h4 id='assoc_type.NodeId' class='type'><code>type NodeId = <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='../../petgraph/visit/trait.Visitable.html' title='petgraph::visit::Visitable'>Visitable</a> for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='impl-items'><h4 id='assoc_type.Map' class='type'><code>type Map = <a class='struct' href='../../fixedbitset/struct.FixedBitSet.html' title='fixedbitset::FixedBitSet'>FixedBitSet</a></code></h4>
<h4 id='method.visit_map' class='method'><code>fn <a href='../../petgraph/visit/trait.Visitable.html#method.visit_map' class='fnname'>visit_map</a>(&amp;self) -&gt; <a class='struct' href='../../fixedbitset/struct.FixedBitSet.html' title='fixedbitset::FixedBitSet'>FixedBitSet</a></code></h4>
</div><h3 class='impl'><code>impl&lt;N, E, Ty, Ix&gt; <a class='trait' href='../../petgraph/visit/trait.GetAdjacencyMatrix.html' title='petgraph::visit::GetAdjacencyMatrix'>GetAdjacencyMatrix</a> for <a class='struct' href='../../petgraph/graph/struct.Graph.html' title='petgraph::graph::Graph'>Graph</a>&lt;N, E, Ty, Ix&gt; <span class='where'>where Ty: <a class='trait' href='../../petgraph/trait.EdgeType.html' title='petgraph::EdgeType'>EdgeType</a>, Ix: <a class='trait' href='../../petgraph/graph/trait.IndexType.html' title='petgraph::graph::IndexType'>IndexType</a></span></code></h3><div class='docblock'><p>The adjacency matrix for <strong>Graph</strong> is a bitmap that&#39;s computed by
<em>.adjacency_matrix()</em>.</p>
</div><div class='impl-items'><h4 id='assoc_type.AdjMatrix' class='type'><code>type AdjMatrix = <a class='struct' href='../../fixedbitset/struct.FixedBitSet.html' title='fixedbitset::FixedBitSet'>FixedBitSet</a></code></h4>
<h4 id='method.adjacency_matrix' class='method'><code>fn <a href='../../petgraph/visit/trait.GetAdjacencyMatrix.html#method.adjacency_matrix' class='fnname'>adjacency_matrix</a>(&amp;self) -&gt; <a class='struct' href='../../fixedbitset/struct.FixedBitSet.html' title='fixedbitset::FixedBitSet'>FixedBitSet</a></code></h4>
<h4 id='method.is_adjacent' class='method'><code>fn <a href='../../petgraph/visit/trait.GetAdjacencyMatrix.html#method.is_adjacent' class='fnname'>is_adjacent</a>(&amp;self, matrix: &amp;<a class='struct' href='../../fixedbitset/struct.FixedBitSet.html' title='fixedbitset::FixedBitSet'>FixedBitSet</a>, a: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;, b: <a class='struct' href='../../petgraph/graph/struct.NodeIndex.html' title='petgraph::graph::NodeIndex'>NodeIndex</a>&lt;Ix&gt;) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div>
            <div class="shortcuts">
                <h1>Keyboard Shortcuts</h1>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h1>Search Tricks</h1>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>typedef</code> (or
                    <code>tdef</code>).
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "petgraph";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script async src="../../search-index.js"></script>
</body>
</html>